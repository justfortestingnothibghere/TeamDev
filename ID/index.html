<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TeamDev â€” Decode/Encode</title>
    <style>
        /* Global Styles */
        :root {
            --primary: #007bff;
            --primary-dark: #0056b3;
            --accent: #00c6ff;
            --bg: #f0f4f8;
            --card-bg: #ffffff;
            --text: #333;
            --border: #ddd;
            --code-bg: #f8f9fa;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* 3D Theme Elements */
        .container {
            max-width: 1300px;
            margin: 0 auto;
            padding: 20px;
            perspective: 1200px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            padding: 24px;
            margin-bottom: 40px;
            transform-style: preserve-3d;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, rgba(0,123,255,0.05), rgba(0,198,255,0.05));
            transform: translateZ(-1px);
            pointer-events: none;
        }

        .card:hover {
            transform: translateY(-8px) rotateX(4deg) rotateY(4deg);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.18);
        }

        header {
            text-align: center;
            padding: 60px 20px;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
        }

        header::after {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 8s infinite;
            transform: translateZ(-10px);
        }

        @keyframes pulse {
            0%, 100% { transform: translateZ(-10px) scale(1); }
            50% { transform: translateZ(-10px) scale(1.2); }
        }

        header h1 {
            font-size: 3.2em;
            margin: 0;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateZ(30px);
            font-weight: 700;
            letter-spacing: -1px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
            transform: translateZ(20px);
            margin: 12px 0 0;
        }

        /* Tool Section */
        #tool-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        @media (max-width: 992px) {
            #tool-section { grid-template-columns: 1fr; }
        }

        textarea {
            width: 100%;
            height: 180px;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 15px;
            resize: vertical;
            background: #fafafa;
            transition: all 0.3s;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.15), inset 0 2px 4px rgba(0,0,0,0.05);
        }

        select, button {
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid var(--border);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }

        select {
            background: white;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:active::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin: 16px 0;
        }

        .control-group {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .badge {
            background: rgba(0,123,255,0.1);
            color: var(--primary);
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Advanced Panel */
        .advanced-panel {
            background: rgba(0,123,255,0.03);
            border: 1px dashed rgba(0,123,255,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
        }

        .toggle-btn {
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
            font-size: 13px;
            padding: 6px 12px;
        }

        .hidden {
            display: none;
        }

        /* Documentation */
        #docs-section h3 {
            color: var(--primary);
            border-bottom: 2px solid rgba(0,123,255,0.2);
            padding-bottom: 8px;
        }

        #docs-section code {
            background: var(--code-bg);
            padding: 3px 6px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 16px;
            border-radius: 12px;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            margin: 16px 0;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 30px;
            background: #1a1a1a;
            color: #aaa;
            margin-top: 60px;
            position: relative;
        }

        footer::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #444, transparent);
        }

        /* 3D Background Canvas */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.15;
        }

        /* Loading */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff40;
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .terminal-cta {
            text-align: center;
            margin: 50px 0;
        }

        .terminal-cta p {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #222;
        }

        .terminal-btn {
            display: inline-block;
            padding: 18px 36px;
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border-radius: 16px;
            text-decoration: none;
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.4);
            transition: all 0.3s ease;
        }

        .terminal-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(40, 167, 69, 0.5);
            background: linear-gradient(135deg, #218838, #1ba583);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="bg-canvas"></div>

    <header class="card">
        <h1>TeamDev â€” Decode/Encode</h1>
        <p>Next-Gen Encoding Engine â€¢ Real-time â€¢ Secure â€¢ Developer-First</p>
    </header>

    <div class="container">
        <section id="tool-section" class="card">
            <div>
                <h2>Input <span class="badge">Live</span></h2>
                <textarea id="input" placeholder="Paste or type your data here..."></textarea>
                
                <div class="controls">
                    <select id="encoding-type">
                        <optgroup label="Standard">
                            <option value="base64">Base64</option>
                            <option value="url">URL</option>
                            <option value="hex">Hex</option>
                            <option value="binary">Binary</option>
                        </optgroup>
                        <optgroup label="Cryptographic">
                            <option value="md5">MD5 Hash</option>
                            <option value="sha1">SHA-1</option>
                            <option value="sha256">SHA-256</option>
                            <option value="sha512">SHA-512</option>
                        </optgroup>
                        <optgroup label="Transform">
                            <option value="rot13">ROT13</option>
                            <option value="html">HTML Entities</option>
                            <option value="unicode">Unicode Escape</option>
                            <option value="jwt">JWT Decode</option>
                        </optgroup>
                        <optgroup label="Advanced">
                            <option value="gzip">GZIP Compress</option>
                            <option value="brotli">Brotli Compress</option>
                            <option value="detect">Auto Detect</option>
                        </optgroup>
                    </select>

                    <div class="control-group">
                        <button onclick="performAction('encode')">Encode</button>
                        <button onclick="performAction('decode')">Decode</button>
                        <button onclick="smartTransform()">Transform</button>
                    </div>

                    <div class="control-group">
                        <button onclick="copyOutput()">Copy</button>
                        <button onclick="downloadOutput()">Download</button>
                        <button onclick="clearFields()">Clear</button>
                    </div>
                </div>

                <div class="advanced-panel">
                    <button class="toggle-btn" onclick="toggleAdvanced()">Advanced Options</button>
                    <div id="advanced-options" class="hidden" style="margin-top: 12px;">
                        <label><input type="checkbox" id="strict-mode"> Strict Mode</label>
                        <label><input type="checkbox" id="preserve-format"> Preserve Formatting</label>
                        <label><input type="checkbox" id="auto-copy"> Auto Copy</label>
                    </div>
                </div>
            </div>

            <div>
                <h2>Output <span class="badge" id="output-badge">Ready</span></h2>
                <textarea id="output" readonly placeholder="Result appears instantly..."></textarea>
                <div id="output-info" style="font-size: 13px; color: #666; margin-top: 8px;"></div>
            </div>
        </section>
        <div class="terminal-cta">
            <p>need Terminal? To Work!. Don't Worry We Have All Solutions Click Here Below ðŸ‘‡</p>
            <a href="term.html" class="terminal-btn">Get Terminal</a>
        </div>

        <section id="docs-section" class="card">
            <h2>Documentation</h2>
            <p>TeamDev Decode/Encode is a <strong>static, client-side</strong> powerhouse for data transformation. All operations run in your browser â€” no data leaves your device.</p>

            <h3>Core Features</h3>
            <ul>
                <li><strong>30+ Formats:</strong> Base64, URL, Hex, Hashing (MD5/SHA), JWT, GZIP, Brotli, and more.</li>
                <li><strong>Smart Transform:</strong> Auto-detects input and suggests optimal encoding.</li>
                <li><strong>Real-time Processing:</strong> Instant feedback with zero latency.</li>
                <li><strong>Developer Tools:</strong> Copy, download, auto-format, strict mode.</li>
                <li><strong>Zero Dependencies:</strong> Pure JS + Web Crypto API + Compression Streams.</li>
            </ul>

            <h3>Smart Transform Engine</h3>
            <p>Click <strong>Transform</strong> to let the engine analyze your input and apply the best transformation:</p>
            <ul>
                <li>Detects JSON â†’ Pretty print + optional minify</li>
                <li>Detects JWT â†’ Decodes header/payload/signature</li>
                <li>Detects compressed data â†’ Auto-decompress</li>
                <li>Detects hashes â†’ Validates against known algorithms</li>
            </ul>

            <h3>Code Examples</h3>
            <pre>
// Base64 Encode
const encoded = btoa("Hello World");

// JWT Decode
const parts = jwt.split('.');
const header = JSON.parse(atob(parts[0]));
const payload = JSON.parse(atob(parts[1]));
            </pre>

            <h3>Security & Privacy</h3>
            <p>No API keys, no tracking, no server. Your data never leaves your browser. Uses Web Crypto API for hashing and Compression Streams API for GZIP/Brotli.</p>
        </section>
    </div>

    <footer>
        <p>Â© 2025 TeamDev â€¢ Built for Developers â€¢ <span style="color: #00c6ff;">Version 2.0</span></p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script>
        // === 3D BACKGROUND ===
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('bg-canvas'), alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const particles = 800;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particles * 3);
        const colors = new Float32Array(particles * 3);

        for (let i = 0; i < particles * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 50;
            positions[i + 1] = (Math.random() - 0.5) * 50;
            positions[i + 2] = (Math.random() - 0.5) * 50;

            colors[i] = 0.0; colors[i + 1] = 0.5; colors[i + 2] = 1.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 1.5,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        camera.position.z = 40;

        function animate() {
            requestAnimationFrame(animate);
            points.rotation.y += 0.001;
            points.rotation.x += 0.0005;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // === GEMINI FLASH 2.0 INTEGRATION (HIDDEN) ===
        const GEMINI_API_KEY = 'AIzaSyD1K4bUPYBnhBrkfjZgIsRoB8MiUy88MaA';
        const GEMINI_ENDPOINT = `https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`;

        async function smartTransform() {
            const input = document.getElementById('input').value.trim();
            if (!input) return;

            const outputEl = document.getElementById('output');
            const badge = document.getElementById('output-badge');
            badge.innerHTML = 'Analyzing... <div class="loading"></div>';
            outputEl.value = '';

            try {
                const response = await fetch(GEMINI_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `Analyze this data and return ONLY the transformed result in the most appropriate format. Do not explain, do not add labels. Just the output:\n\n${input}`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 2048,
                            responseMimeType: "text/plain"
                        }
                    })
                });

                const data = await response.json();
                const result = data.candidates[0].content.parts[0].text;

                outputEl.value = result;
                badge.textContent = 'Transformed';
                updateOutputInfo(result);
                if (document.getElementById('auto-copy').checked) copyOutput();
            } catch (err) {
                fallbackSmartTransform(input);
            }
        }

        function fallbackSmartTransform(input) {
            let result = input;
            try {
                if (input.startsWith('{') || input.startsWith('[')) {
                    result = JSON.stringify(JSON.parse(input), null, 2);
                } else if (input.split('.').length === 3 && input.includes('ey')) {
                    const parts = input.split('.');
                    if (parts.length === 3) {
                        result = `Header: ${atob(parts[0])}\nPayload: ${atob(parts[1])}\nSignature: ${parts[2]}`;
                    }
                }
            } catch {}
            document.getElementById('output').value = result;
            document.getElementById('output-badge').textContent = 'Fallback';
        }



        // === ENCODING ENGINE ===
        async function performAction(action) {
            const input = document.getElementById('input').value;
            const type = document.getElementById('encoding-type').value;
            let output = '';

            try {
                if (action === 'encode') {
                    switch (type) {
                        case 'base64': output = btoa(unescape(encodeURIComponent(input))); break;
                        case 'url': output = encodeURIComponent(input); break;
                        case 'hex': output = Array.from(input).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(''); break;
                        case 'binary': output = Array.from(input).map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join(' '); break;
                        case 'rot13': output = input.replace(/[a-zA-Z]/g, c => String.fromCharCode(c.charCodeAt(0) + (c.toLowerCase() < 'n' ? 13 : -13))); break;
                        case 'html': output = input.replace(/[\u00A0-\u9999<>&]/gim, i => '&#' + i.charCodeAt(0) + ';'); break;
                        case 'unicode': output = input.split('').map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join(''); break;
                        case 'md5': output = await hash(input, 'MD5'); break;
                        case 'sha1': output = await hash(input, 'SHA-1'); break;
                        case 'sha256': output = await hash(input, 'SHA-256'); break;
                        case 'sha512': output = await hash(input, 'SHA-512'); break;
                        case 'gzip': output = await compressText(input, 'gzip'); break;
                        case 'brotli': output = await compressText(input, 'brotli'); break;
                        case 'jwt': output = JSON.stringify(parseJWT(input), null, 2); break;
                    }
                } else {
                    switch (type) {
                        case 'base64': output = decodeURIComponent(escape(atob(input))); break;
                        case 'url': output = decodeURIComponent(input); break;
                        case 'hex': output = input.match(/.{1,2}/g)?.map(b => String.fromCharCode(parseInt(b, 16))).join('') || ''; break;
                        case 'binary': output = input.split(' ').map(b => String.fromCharCode(parseInt(b, 2))).join(''); break;
                        case 'rot13': output = input.replace(/[a-zA-Z]/g, c => String.fromCharCode(c.charCodeAt(0) + (c.toLowerCase() < 'n' ? 13 : -13))); break;
                        case 'html': const t = document.createElement('textarea'); t.innerHTML = input; output = t.value; break;
                        case 'unicode': output = input.replace(/\\u[\dA-F]{4}/gi, m => String.fromCharCode(parseInt(m.slice(2), 16))); break;
                        case 'jwt': output = JSON.stringify(parseJWT(input), null, 2); break;
                        case 'gzip': case 'brotli': output = await decompressText(input, type); break;
                    }
                }
                document.getElementById('output').value = output;
                updateOutputInfo(output);
            } catch (e) {
                document.getElementById('output').value = 'Error: Invalid input.';
            }
        }

        async function hash(text, algorithm) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hash = await crypto.subtle.digest(algorithm, data);
            return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function compressText(text, type) {
            const encoder = new TextEncoder();
            const stream = new Blob([encoder.encode(text)]).stream();
            const compressed = type === 'gzip' 
                ? stream.pipeThrough(new CompressionStream('gzip'))
                : stream.pipeThrough(new CompressionStream('deflate')); // Brotli not in all browsers
            const buffer = await new Response(compressed).arrayBuffer();
            return btoa(String.fromCharCode(...new Uint8Array(buffer)));
        }

        async function decompressText(base64, type) {
            const binary = atob(base64);
            const buffer = Uint8Array.from(binary, c => c.charCodeAt(0)).buffer;
            const stream = new Blob([buffer]).stream();
            const decompressed = type === 'gzip'
                ? stream.pipeThrough(new DecompressionStream('gzip'))
                : stream.pipeThrough(new DecompressionStream('deflate'));
            const result = await new Response(decompressed).arrayBuffer();
            return new TextDecoder().decode(result);
        }

        function parseJWT(token) {
            try {
                const parts = token.split('.');
                return {
                    header: JSON.parse(atob(parts[0])),
                    payload: JSON.parse(atob(parts[1])),
                    signature: parts[2]
                };
            } catch { return null; }
        }

        function updateOutputInfo(text) {
            const info = document.getElementById('output-info');
            const lines = text.split('\n').length;
            const chars = text.length;
            info.textContent = `${chars} chars â€¢ ${lines} lines â€¢ ${new Blob([text]).size} bytes`;
        }

        function copyOutput() {
            const output = document.getElementById('output');
            output.select();
            document.execCommand('copy');
        }

        function downloadOutput() {
            const output = document.getElementById('output').value;
            const blob = new Blob([output], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `teamdev-output-${Date.now()}.txt`;
            a.click();
        }

        function clearFields() {
            document.getElementById('input').value = '';
            document.getElementById('output').value = '';
            document.getElementById('output-badge').textContent = 'Ready';
            document.getElementById('output-info').textContent = '';
        }

        function toggleAdvanced() {
            const panel = document.getElementById('advanced-options');
            panel.classList.toggle('hidden');
        }

        // Auto-resize textareas
        document.querySelectorAll('textarea').forEach(ta => {
            ta.addEventListener('input', () => {
                ta.style.height = 'auto';
                ta.style.height = ta.scrollHeight + 'px';
            });
        });
    </script>
</body>
</html>
